# Interview preparation

**Code Standards: Какие стандарты кода и принципы программирования существуют.**

**Стандарты**:

1. Стремиться к тому чтобы код компилировался без предупреждений
2. Использовать информативные и согласованные имена (из соглашения об именах swift, отмеченные в руководстве по разработке api)
3. Критично не называть методы двусмысленно
4. Использовать экстеншены для создания логических блоков кода. Каждый экстеншен должен быть описан через МАРК
5. Не импортировать ненужные библиотеки
6. Отступ 2 пробела вместо табуляции для экономии места и предотвращения переноса строк
7. Фигурные скобки (метода, циклов и тд) всегда открываются на той же строке что и оператор, но закрываются всегда на новой строке
8. Между методами должна быть одна пустая строка
9. Добавлять полезные комментарии там где они нужны
10. Стараться избегать С-подобных комментариев в угоду несколько однострочным

**Принципы**: _DRY, YAGNI, KISS, принцип разделения ответственности_ DRY - Don't Repeat Yourself (WET - Write Everything Twice) : Пытаться не писать повторяющийся код, вместо это использовать классы, методы и тд YAGNI - You aren't gonna need it Суть в том, чтобы не писать код, который потенциально может не пригодиться. Как пример, это может быть код для создания какой-то фичи в будущем, которая возможно в будущем окажется вообще ненужной, или этот код помешает созданию нужной фичи сейчас KISS - Keep It Simple, Stupid: - разбивать большие задачи на подзадачи, которые будут длиться не более 4-12 часов написания кода - каждая задача должна решаться одним-двумя классами - сохранять методы маленькими - не бояться избавляться от ненужного кода - придумать решение задачи, потом писать код Less is more (Чем хуже, тем лучше): простота реализации и простота интерфейса более важные, чем любые другие свойства системы Принцип разделения ответственности: позволяет снизить системную сложность, повысить надёжность и адаптивность программ, обеспечить возможность их повторного использования (по сути рекоммендует использовать шаблон проектирования MVC, MVVP и тд)

**Алгоритмы: Что такое алгоритм. Примеры алгоритмов.**

**Алгоритмы**:

* Бинарный поиск:
  1. Даётся упорядоченная коллекция, в которой нужно найти элемент (будем звать его `target`).
  2. Выбирается элемент в середине (если им оказывается `target` — возвращается его индекс)
  3. Если `target` оказывается меньше среднего элемента, то поиск смещается в левую часть массива. В противном случае смещение происходит вправо.
* Сортировка пузырьком:
  1. Происходит сравнение двух рядомстоящих элементов массива начиная с a\[0]
  2. Большее число переносится вправо
  3. После завершения прохода 1 наибольшее значение пришло к последнему индексу массива, поэтому теперь мы выполним проход 2 от 0-го элемента ко второму последнему элементу массива
* Быстрая сортировка:
  1. Из массива выбирается некий опорный элемент a\[i] (pivot)
  2. Запускается процедура разделения массива, которая перемещает все ключи, меньшие, либо равные a\[i], влево от него, а все ключи, большие, либо равные a\[i] - вправо.
  3. Теперь массив состоит и двух подмножеств, причем левое меньше, либо равно правого.
  4. Для обоих подмассивов: если в подмассиве более двух элементов, рекурсивно запускаем для него ту же процедуру
* Сортировка слиянием:
  1. Список рекурсивно разделяется пополам, пока в итоге не получатся списки размером в один элемент
  2. Соседние элементы сравниваются и соединяются вместе. Это происходит до тех пор, пока не получится полный отсортированный список
  3. Сортировка осуществляется путём сравнения наименьших элементов каждого подмассива
  4. Первые элементы каждого подмассива сравниваются первыми. Наименьший элемент перемещается в результирующий массив.
  5. Счётчики результирующего массива и подмассива, откуда был взят элемент, увеличиваются на 1.
* Сортировка вставкой:
  1. Нужно перебрать все элементы массива кроме первого, поскольку первый элемент в неотсортированном массиве становится первым элементом в отсортированном массиве
  2. Выбираем первый элемент в неотсортированном массиве. Переменная `element` представляет число, которое мы будем перемещать в отсортированный массив, переменная `j` представляет индекс первого элемента в неотсортированном массиве.
  3. Перебираем справа налево все элементы отсортированного массива, сравнивая их с переменной `element`, перебор прекратится если элемент слева будет меньше, чем переменная `element`
  4. Перемещаем каждый элемент, который больше чем `element` на одну позицию вправо
  5. Обновляем счётчик, чтобы продолжать движение по отсортированному массиву, если элемент слева больше переменной `element`
  6. Вставляем переменную `element` в отсортированную часть списка

**Структуры данных: Основные структуры данных (Массивы, Стеки, Очереди)**

**Структуры данных**:

* _Массив_: Это структура данных для упорядоченного хранения элементов одного типа. Сразу выделяется память под N элементов, и они хранятся последовательно друг за другом. Бывают два типа массивов:
  1. Статический - когда массив имеет неизменяемую длину.
  2. Динамический - сначала выделяется память под N элементов, и если мы хотим добавить больше элементов, то выделяется память большего размера, все старые элементы записываются в новую память, и добавляются новые элементы.
* _Стек_: Это структура данных, представляющая из себя упорядоченный набор элементов, в которой добавление новых элементов и удаление существующих производится с одного конца, называемого вершиной стека. Есть 3 операции:
  * Push() - добавление нового элемента на вершину стека
  * Pop() - удаление первого элемента из вершины стека
  * Peek() - возвращает первый элемент из вершины стека Можно реализовать с помощью динамического массива.
* _Очередь_: Это структура данных типа «список», позволяющая добавлять элементы лишь в конец списка, и извлекать их из его начала. То есть в очереди реализуется принцип «первым вошел — первым вышел» (англ. first-in, first-out — FIFO). Есть 2 операции:
  * Enqueue() - добавление нового элемента в конце списка
  * Dequeue() - удаление элемента в начале списка

**Breakpoints: Работа с Breakpoints (Точки останова) и LLDB консоли**

***

**Другое: Как получить и зачем нужен Stack trace. Отладка UI компонентов.**

**Stack Trace** - это отчёт о действующих элементах стека в определённый момент времени во время выполнения программы. Используется обычно для интерактивной или посмертной отладки. Конечные пользователи могут увидеть трассировку стека как часть сообщения об ошибке, о которой они могут затем сообщить программисту. _Трассировка стека позволяет отслеживать последовательность вызванных функций_ - до точки, в которой трассировка стека была создана. В посмертном сценарии это распространяется на функцию, в которой произошел сбой.

**Зачем нужны тесты.**\
**Какие виды тестов существуют.** **Mock\Spy тестирование.**

**Какие системы контроля версий существуют.**\
**Зачем нужны системы контроля версий.**\
**Работа с Git репозиторием.** Централизованные (CVCS) и распределённые (DVCS) Git, Mercurial, SVN и Perforce

**Общее: Какие методологии разработки существуют. Зачем нужно придерживаться методологии разработки на проекте.**

* Скрам
* Канбан
* ХР
* Вотерфолл
* Итеративная && инкрементная

**Знание синтаксиса и базовых конструкций языка. Optionals. Протоколы. Модификаторы доступа. Бриджинг с Obj-C, Extensions, structures, tuples, enums, computed properties**\
**Определение замыкания, зачем оно нужно.**

**Optionals unwrapping**:

1. If-else block

```swift
var variable:String? //evaluates to nil

if variable != nil{
 print("Not nil")
}
else{
 print("Nil")
}
```

2\. Forced unwrapping

```swift
var color:String?;

print(color!) // Unexpectedly found nil while unwrapping an Optional value
```

3\. Optional binding

```swift
var password:String?

if let unwrap = password{ // Block unexecuted, as optional password is nil.
	print("value is not nil")
}
```

4\. Optional chaining Даст значение только в том случае, если проходясь по цепочке слева-направо не наткнётся на nil

```swift
let album = albumReleased(year: 2006)?.someOptionalValue?.someOtherOptionalValue?
print("The album is \(album)")
```

5\. Nil coalescing operator

```swift
var text:String?

var output = text ?? "Default value"

print(output) // Default value

text = "This is a string"

output = text ?? "Default String"

print(output) // This is a string
```

**Модификаторы доступа**: –– `internal` (он же отсутствие модификатора) - виден внутри модуля в котором определен. Можно наследоваться, переопределять в рамках модуля в котором определен. Т.е. если Вы, к примеру, просто создали Single View App - это рамки одного модуля, подключили какой-либо фреймворк - это другой модуль, и все что в нем не отмечено как public или open - не видно внутри вашего модуля.

–– `private` - для сокрытия реализации, виден только в рамках декларации. С недавнего времени также виден и в расширениях декларации.

–– `fileprivate` - аналогичен `private`, если придерживаться "один класс - один файл". Виден в рамках одного файла. Если в файле несколько деклараций, то можно получить доступ к декларации/ее содержимому из другой в этом файле.

–– `public` - виден в других модулях, нельзя наследоваться и переопределять.

–– `open` - виден в других модулях. Можно наследоваться, переопределять.

_**Протокол**_ определяет план методов, свойств и других требований, которые подходят для конкретной задачи или части функциональности. Затем протокол может быть _принят_ классом, структурой или перечислением, чтобы обеспечить фактическую реализацию этих требований. Говорят, что любой тип, который удовлетворяет требованиям протокола, _соответствует_ этому протоколу.

**Расширения** добавляют новую функциональность существующему типу класса, структуры или перечисления. Это включает в себя возможность расширять типы, к исходным кодам которых у вас нет доступа.

**Кортежи** или **Tuples** представляют набор значений, которые рассматриваются как один объект. Для создания кортежа используются скобки, внутри которых записываются все элементы кортежа.

**Перечисление** (enumeration) определяет общий тип для группы связанных значений. Причем сами объединенные в перечисление значения могут представлять любой тип - число, строку и так далее.

**Понимание систем координат, frame/bounds. Subview/superview. Знание иерархии классов UIKit. Иерархия UIView на экране. Умение работы с Interface Builder. Жизненный цикл ViewController. Умеет создавать интерфейсы в Storyboard и Xib. Верстка на Autolayout и Autoresizing Mask. UIAppearance**

**frame** — расположение и размер view с использованием системы координат родительского представления (важно для размещения представления в superview).

**bounds** — местоположение и размер представления с использованием его собственной системы координат (важно для размещения содержимого View или subview внутри него)

**Subview/superview**: Если одно вью содержит в себе другое вью - между ними устанавливаются отношения parent-child. Child-view в отношениях будет считаться subview, и, соответственно, parent-view будет superview.

**Auto Layout** занимается динамическим вычислением позиции и размера всех _view_ в _view_ иерархии, на основе _constraints_ — правил заданных для того или иного _view_.

**Autoresizing Mask** - это инструмент, с помощью которого мы можем устанавливать различные правила для элементов интерфейса, благодаря которым они будут подстраиваться под изменения супервью.

**UIAppearance** - это протокол, предоставляющий прокси-объект, который используется для конфигурирования объектов конкретного класса. По сути с помощью этого протокола мы можем задать единый внешний вид для всего класса (например, UIButton).

**Иерархия классов UIKit**:



**Какие технологии в iOS возможно использовать для работы с потоками. Преимущества и недостатки.**\
**Grand Central Dispatch (GCD). Async, Sync.**

**Технологии**:

* _GCD_ (Grand Central Dispatch)
* _Operation_ - построено поверх GCD и рекоммендуется к использованию вместо GCD, т.к. имеет более высокий уровень абстракции.

**Преимущество GCD над NSOperation**:\
i. `GCD` очень легковесный, `NSOperationQueue` очень комплексный и тяжелый (медленнее)

**Преимущества NSOperation над GCD**:

i. Control On Operation Мы можем сделать Pause, Cancel, Resume для `NSOperation`

ii. Dependencies Мы можем установить зависимость между двумя `NSOperations`\
операциями, операциями, тогда операции не будут запущены до тех пор, пока все зависимости не вернут true.

iii. State of Operation\
Можно мониторить состояние операции, или очереди: _ready_, _executing_ или _finished_

iv. Max Number of Operation\
Мы можем задать максимальное количество операций в очереди, которые могут выполняться одновременно

When to Go for `GCD` or `NSOperation`: when you want more control over queue (all above mentioned) use `NSOperation` and for simple cases where you want less overhead (you just want to do some work "into the background" with very little additional work) use `GCD`



**Проблемы потоков**:

1. **Race Condition** (Условия гонки): С несколькими потоками, при работе с одними данными, в результате чего сами данные становятся непредсказуемыми и зависят от порядка выполнения потоков.
2. **Resourse contention** (Конкуренция за ресурс): Несколько потоков, выполняющих разные задачи, пытаются получить доступ к одному ресурсу, тем самым увеличивая время, необходимое для безопасного получения ресурса. Эта задержка может привести к непредвиденному поведению.
3. **Deadlock** (Вечная блокировка): Несколько потоков блокируют друг друга.
4. **Starvation** (Голодание): Поток не может получить доступ к ресурсу и безуспешно пытается сделать это снова и снова.
5. **Priority Inversion** (Инверсия приоритетов): Поток с низким приоритетом удерживает ресурсы, которые требуются другому потоку с более высоким приоритетом.
6. **Non-deterministic and Fairness** (Неопределённость и справедливость): Мы не можем делать предположений когда, и в каком порядке поток сможет получить ресурс. Эта задержка не может быть определена априори, и в значительной степени зависит от количества конфликтов. Однако, примитивы синхронизации могут обеспечить справедливость, гарантируя доступ всем потокам которые ожидают, также учитывая порядок.

**NSURLSession. JSONSerialization, использование фреймворков для построения API Layer (Запросы, парсинг, и т.д.)**\
**Postman.Swagger**

Alamofire, Moya
